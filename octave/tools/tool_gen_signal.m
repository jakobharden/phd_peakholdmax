## Generate (damped) sinusoidal signal#### Usage: [r_ss, r_nn, r_ns] = tool_gen_signal(p_fs, p_nc, p_sp)#### p_fs ... sampling frequency, Hz, <uint>## p_nc ... number of cycles, <uint>## p_sp ... signal model parameter array, see below, [<dbl>]## r_ss ... return: signal amplitude array, [<dbl>]## r_nn ... return: sample index array, [<dbl>]## r_ns ... return: total number of samples, <uint>#### Signal model parameter array:##   p_sp = [A, F, beta]##     A    ... amplitude scaling factor##     F    ... frequency##     beta ... exponential decay factor, the decay is always related to one full cycle#### Note: the exponential decay factor is related to one cycle########################################################################################################################### LICENCE####    Copyright (C) 2025 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)##    This file is part of the PhD thesis of Jakob Harden.####    This program is free software: you can redistribute it and/or modify##    it under the terms of the GNU Affero General Public License as##    published by the Free Software Foundation, either version 3 of the##    License, or (at your option) any later version.####    This program is distributed in the hope that it will be useful,##    but WITHOUT ANY WARRANTY; without even the implied warranty of##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the##    GNU Affero General Public License for more details.####    You should have received a copy of the GNU Affero General Public License##    along with this program.  If not, see <https://www.gnu.org/licenses/>.###########################################################################################################################function [r_ss, r_nn, r_ns] = tool_gen_signal(p_fs, p_nc, p_sp)    ## check arguments  if (nargin < 3)    help tool_gen_signal;    error('Less arguments given!');  endif    ## number of samples  r_ns = floor(p_nc * p_fs / p_sp(2));    ## sample index array  r_nn = 1 : r_ns;    ## exponential part, argument  ww0 = linspace(0, 1, r_ns);    ## sinusoidal part, argument  ww1 = ww0 * p_nc * 2 * pi;    ## generate signal  r_ss = p_sp(1) * sin(ww1) .* exp(p_sp(3) * p_nc * ww0);  endfunction